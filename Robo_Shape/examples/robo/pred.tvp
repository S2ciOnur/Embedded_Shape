// For every program variable z there is a unary predicate that holds for
// list elements pointed by z.
// The unique property is used to convey the fact that the predicate can hold
// for at most one individual.
// The pointer property is a visualization hint for graphical renderers.
%s HVar{r1,r2,r3,c1,c2,c3}
%s rows{r1,r2,r3}
%s columns{c1,c2,c3}
// Menge von Markierungen
%s marks{marked_O, marked_X}
foreach (z in HVar) {
  %p z(v_1) unique pointer
}

// The predicate n represents the rn field of the list data type.
%p rn(v_1, v_2) function acyclic

// The predicate n represents the cn field of the list data type.
%p cn(v_1, v_2) function acyclic


// The t[rn] predicate records transitive reflexive reachability between
// list elements along the rn field.
%i t[rn](v_1, v_2) = rn*(v_1, v_2) transitive reflexive

// The t[cn] predicate records transitive reflexive reachability between
// list elements along the cn field.
%i t[cn](v_1, v_2) = cn*(v_1, v_2) transitive reflexive


%p marked_X(v) 
%p marked_O(v)

// predicates
%i marked(v) = marked_X(v) | marked_O(v)

// Gehe durch alle Rows
// gehe durch alle markierten in rows
// Wenn alle 3 v = true dann win_marked_row = true
// r(v1,v2) zum springen von f11 -> f12 benötigt
foreach (r in rows) {
	foreach(x in marks) {
	%i win_marked_row[r,x]() = E(v1,v2,v3) r(v1) & x(v1) & rn(v1,v2) & x(v2) & rn(v2,v3) & x(v3)
	}
}
%i win_marked_row() = 
	win_marked_row[r1,marked_X]() | win_marked_row[r2,marked_X]() | win_marked_row[r3,marked_X]()
	| win_marked_row[r1,marked_O]() | win_marked_row[r2,marked_O]() | win_marked_row[r3,marked_O]()
	
	
// Gehe durch alle Columns
// gehe durch alle markierten in columns
// Wenn alle 3 v = true dann win_marked_columns = true
// c(v1,v2) zum springen von f11 -> f21 benötigt
foreach (c in columns) {
	foreach(x in marks) {
	%i win_marked_column[c,x]() = E(v1,v2,v3) c(v1) & x(v1) & cn(v1,v2) & x(v2) & cn(v2,v3) & x(v3)
	}
}
%i win_marked_column() = 
	win_marked_column[c1,marked_X]() | win_marked_column[c2,marked_X]() | win_marked_column[c3,marked_X]()
	| win_marked_column[c1,marked_O]() | win_marked_column[c2,marked_O]() | win_marked_column[c3,marked_O]()