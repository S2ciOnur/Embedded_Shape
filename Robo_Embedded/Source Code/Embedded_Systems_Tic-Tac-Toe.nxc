#define SENSOR_ABSTAND 25 //cm

//Koordinaten der Zellen
int cell_x[] = {0,93,186,0,93,186,0,93,186};
int cell_y[] = {2049,2049,2049,1366,1366,1366,683,683,683};

//Initiales Spielfeld
int playfield[] = {0,0,0,0,0,0,0,0,0};

int current_x=0;
int current_y=-3683;
int white=0;
int symbol=1;   //'X'
int op_symbol=2;//'O'
int cell=0;
int data[9];
int child_array[10];
int first_op=0;
int trick=1;
int max=0;
int min=0;
int move=0;
int best_cell=0;
int moves_left=0;
int lcd=0;
int id=0;
int child=0;
int move_x;
int move_y;

bool found_symbol=false;
bool scan=false;
bool win=false;

mutex moveMutex_x, moveMutex_y;

int[][] oneDimPlayfieldToTwoDim(int playfield[]){
    int playfieldNew[3][3] = {{0}};
    playfieldNew[1][1] = playfield[1];
    playfieldNew[1][2] = playfield[2];
    playfieldNew[1][3] = playfield[3];
    playfieldNew[2][1] = playfield[4];
    playfieldNew[2][2] = playfield[5];
    playfieldNew[2][3] = playfield[6];
    playfieldNew[3][1] = playfield[7];
    playfieldNew[3][2] = playfield[8];
    playfieldNew[3][3] = playfield[9];
	
	return playfieldNew;
}

/**
 * Stift absetzen
 */
void pen_down() {
    OnFwd(OUT_A, 15);
    Wait(250);
    Float(OUT_A);
}

/**
 * Stift anheben
 */
void pen_up(){
    RotateMotor(OUT_A,20,-15);
}

/**
 * Stiftmotor bewegen
 */
task move_yf(){
    RotateMotor(OUT_C,100,move_y);
    Release(moveMutex_y);
}
task move_xf(){
    RotateMotor(OUT_B,20,move_x);
    Release(moveMutex_x);
}

/**
 * Stift bewegen
 */
void move_pen(int x, int y){
     Acquire(moveMutex_x);
     Acquire(moveMutex_y);

     move_x = x - current_x;
     move_y = current_y - y;

     current_x = x;
     current_y = y;

     start move_xf;
     start move_yf;
}

/**
 * Gegnerisches Symbol finden durch Lichtsensor
 */
int find_symbol() {

	// der gescannte Untergrund
	int scanned_ground = 0;

	int light;
	int i=0;
	int count=0;
	int lines=0;
	int temp=0;
	int j=0;

	// Sensor an und neutralen Untergrund merken
    SetSensorLight(IN_1);
    for(i=0; i<5; i++)
        white = Sensor(IN_1);

    i=0;

    while(!found_symbol){

		if(playfield[i]==0){
            found_symbol = false;

			// durch Zellen navigieren
			move_pen(cell_x[i]+45, cell_y[i]-130-1576);
			Acquire(moveMutex_x);
			Acquire(moveMutex_y);
			Release(moveMutex_x);
			Release(moveMutex_y);
			Acquire(moveMutex_x);
			Acquire(moveMutex_y);
			Release(moveMutex_x);
			Release(moveMutex_y);

			for(j=0;j<10;j++){
				scanned_ground = Sensor(IN_1);
			}

			// falls Unterschied bemerkbar => gefunden
			if(scanned_ground < white - 2) {
				found_symbol = true;
			}
            Wait(500);
        }

        i++;

        if(i == 9 && !found_symbol)
            i=0;
    }

    return i-1;
}

/**
 * Erkennung, dass Gegner zeichnet // weiterer Spielverlauf
 */
void ultrasensor(){

    int temp=0;
    int i=0;
    SetSensorLowspeed(IN_2);
    ClearScreen();

    for(i=0; i<5; i++){
        temp = SensorUS(IN_2);
    }

    while(SensorUS(IN_2) > SENSOR_ABSTAND){
        TextOut(0,LCD_LINE1,"Warte auf Gegner...");
    }

}

//TODO Ablauf klaeren der vier Tasks

/**
 * 'X' zeichnen --> Aufteilung in einzelne Tasks
 */
task draw_x4() {
    RotateMotor(OUT_C,100,330); //y-axis
    pen_up(); //Stilos - OFF
    RotateMotor(OUT_C,100,-330); //y-axis
}

task draw_x3() {
    pen_down(); //Stilos - ON
    start draw_x4;
    RotateMotor(OUT_B,20,-53); //x-axis
}

task draw_x2(){
    RotateMotor(OUT_C,100,330); //y-axis
    pen_up(); //Stilos - OFF
    RotateMotor(OUT_C,100,-330); //y-axis
    start draw_x3;
}

task draw_x1() {
    pen_down(); //Stilos - ON
    start draw_x2;
    RotateMotor(OUT_B,20,53); //x-axis
}


/**
 * 'X' in Zelle zeichnen
 */
void mark_cell(int x) {
    move_pen(cell_x[x] + 20, cell_y[x] - 176);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    start draw_x1;

    Wait(6000);
}

/**
 * Spielfeld zeichnen
 */
void draw_board() {
    move_pen(0,683);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_down(); //Stift - absetzen
    move_pen(279,683);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_up(); //Stift - anheben

    move_pen(279,1366);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_down(); //Stift - absetzen
    move_pen(0,1366);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_up(); //Stift - anheben

    move_pen(93,2049);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_down(); //Stift - absetzen
    move_pen(93,0);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_up(); //Stift - anheben

    move_pen(186,0);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_down(); //Stift - absetzen
    move_pen(186,2049);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_up(); //Stift - anheben

    move_pen(0,-3683);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);
}

/*
 * Main-Task
 */
task main(){

    int i=0;
    int j=0;
    int k=0;
    int p_data[9];
    int temp_data[9];
    int c_node=0;
    int turns_num=9;
    int child_num=0;
    int child_total=0;
    int tree_nodes=0;
    int change_symbol=0;
    int op_mark=0;
    int turns=9;

    // Feld zeichnen
    draw_board();

    // Robo faengt immer an
    ClearScreen();
    TextOut(0,LCD_LINE1,"Ich beginne");
    Wait(5000);

    // Robo macht ersten Zug in Zelle 4 (Mitte)
    op_symbol = 2;
    mark_cell(4);
    playfield[4] = 1;

    // simulieren des Abwechselns
    change_symbol = 2;

    turns_num--;
    move_pen(0,-3683);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    //fuer jede Runde
    for(turns=0; turns<turns_num; turns++){

        if(win == false){
            // layer = Baum tiefe
            layer_4_nodes = 0;
            layer_3_nodes = 0;
            layer_2_nodes = 0;
            child_total=0;

            // zu Beginn trat noch kein Spielstand ein, daher auf 0 gesetzt
            for(i=0;i<401;i++){
                nodes[i].active = 0;
            }


            move_pen(15,-3683);
            Acquire(moveMutex_x);
            Acquire(moveMutex_y);
            Release(moveMutex_x);
            Release(moveMutex_y);

            //Spielendstaende => Unentschieden oder Sieg
            if(win == false){
                ClearScreen();
                TextOut(0,LCD_LINE1,"Unentschieden");
            }
            else{
                ClearScreen();
                TextOut(0,LCD_LINE1,"Sieg");
            }

            Wait(10000);
            move_pen(0,-3683);

        }
    }
}