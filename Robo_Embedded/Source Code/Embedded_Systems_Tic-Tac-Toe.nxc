#define SENSOR_ABSTAND 25 //cm

//Koordinaten der Zellen
int cell_x[] = {0,93,186,0,93,186,0,93,186};
int cell_y[] = {2049,2049,2049,1366,1366,1366,683,683,683};

//Initiales Spielfeld
int playfield[] = {0,0,0,0,0,0,0,0,0};
int playfieldTwoDim[3][3] = {{0}};


int current_x=0;
int current_y=-3683;
int white=0;
int symbol=1;   //'X'
int op_symbol=2;//'O'
int cell=0;
int data[9];
int child_array[10];
int first_op=0;
int trick=1;
int max=0;
int min=0;
int move=0;
int best_cell=0;
int lcd=0;
int id=0;
int move_x;
int move_y;

bool found_symbol=false;
bool scan=false;
bool win=false;

mutex moveMutex_x, moveMutex_y;

void oneDimPlayfieldToTwoDim(){

    playfieldTwoDim[1][1] = playfield[1];
    playfieldTwoDim[1][2] = playfield[2];
    playfieldTwoDim[1][3] = playfield[3];
    playfieldTwoDim[2][1] = playfield[4];
    playfieldTwoDim[2][2] = playfield[5];
    playfieldTwoDim[2][3] = playfield[6];
    playfieldTwoDim[3][1] = playfield[7];
    playfieldTwoDim[3][2] = playfield[8];
    playfieldTwoDim[3][3] = playfield[9];
}

/**
 * Stift absetzen
 */
void pen_down() {
    OnFwd(OUT_A, 15);
    Wait(250);
    Float(OUT_A);
}

/**
 * Stift anheben
 */
void pen_up(){
    RotateMotor(OUT_A,20,-15);
}

/**
 * Stiftmotor bewegen
 */
task move_yf(){
    RotateMotor(OUT_C,100,move_y);
    Release(moveMutex_y);
}
task move_xf(){
    RotateMotor(OUT_B,20,move_x);
    Release(moveMutex_x);
}

/**
 * Stift bewegen
 */
void move_pen(int x, int y){
     Acquire(moveMutex_x);
     Acquire(moveMutex_y);

     move_x = x - current_x;
     move_y = current_y - y;

     current_x = x;
     current_y = y;

     start move_xf;
     start move_yf;
}

/**
 * Gegnerisches Symbol finden durch Lichtsensor
 */
int find_symbol() {

	// der gescannte Untergrund
	int scanned_ground = 0;

	int light;
	int i=0;
	int count=0;
	int lines=0;
	int temp=0;
	int j=0;

	// Sensor an und neutralen Untergrund merken
    SetSensorLight(IN_1);
    for(i=0; i<5; i++)
        white = Sensor(IN_1);

    i=0;

    while(!found_symbol){

		if(playfield[i]==0){
            found_symbol = false;

			// durch Zellen navigieren
			move_pen(cell_x[i]+45, cell_y[i]-130-1576);
			Acquire(moveMutex_x);
			Acquire(moveMutex_y);
			Release(moveMutex_x);
			Release(moveMutex_y);
			Acquire(moveMutex_x);
			Acquire(moveMutex_y);
			Release(moveMutex_x);
			Release(moveMutex_y);

			for(j=0;j<10;j++){
				scanned_ground = Sensor(IN_1);
			}

			// falls Unterschied bemerkbar => gefunden
			if(scanned_ground < white - 2) {
				found_symbol = true;
			}
            Wait(500);
        }

        i++;

        if(i == 9 && !found_symbol)
            i=0;
    }

    return i-1;
}

/**
 * Erkennung, dass Gegner zeichnet // weiterer Spielverlauf
 */
void ultrasensor(){

    int temp=0;
    int i=0;
    SetSensorLowspeed(IN_2);
    ClearScreen();

    for(i=0; i<5; i++){
        temp = SensorUS(IN_2);
    }

    while(SensorUS(IN_2) > SENSOR_ABSTAND){
        TextOut(0,LCD_LINE1,"Warte auf Gegner...");
    }

}

//TODO Ablauf klaeren der vier Tasks

/**
 * 'X' zeichnen --> Aufteilung in einzelne Tasks
 */
task draw_x4() {
    RotateMotor(OUT_C,100,330); //y-axis
    pen_up(); //Stilos - OFF
    RotateMotor(OUT_C,100,-330); //y-axis
}

task draw_x3() {
    pen_down(); //Stilos - ON
    start draw_x4;
    RotateMotor(OUT_B,20,-53); //x-axis
}

task draw_x2(){
    RotateMotor(OUT_C,100,330); //y-axis
    pen_up(); //Stilos - OFF
    RotateMotor(OUT_C,100,-330); //y-axis
    start draw_x3;
}

task draw_x1() {
    pen_down(); //Stilos - ON
    start draw_x2;
    RotateMotor(OUT_B,20,53); //x-axis
}


/**
 * 'X' in Zelle zeichnen
 */
void mark_cell(int x) {
    move_pen(cell_x[x] + 20, cell_y[x] - 176);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    start draw_x1;

    Wait(6000);
}

/**
 * Spielfeld zeichnen
 */
void draw_board() {
    move_pen(0,683);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_down(); //Stift - absetzen
    move_pen(279,683);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_up(); //Stift - anheben

    move_pen(279,1366);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_down(); //Stift - absetzen
    move_pen(0,1366);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_up(); //Stift - anheben

    move_pen(93,2049);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_down(); //Stift - absetzen
    move_pen(93,0);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_up(); //Stift - anheben

    move_pen(186,0);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_down(); //Stift - absetzen
    move_pen(186,2049);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    pen_up(); //Stift - anheben

    move_pen(0,-3683);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);
}

/*
 * Main-Task
 */
task main(){

    int i=0;
    int j=0;
    int k=0;
    int p_data[9];
    int temp_data[9];
    int c_node=0;
    int turns_num=9;
    int child_num=0;
    int child_total=0;
    int change_symbol=0;
    int op_mark=0;
    int turns=9;

    // Feld zeichnen
    draw_board();

    // Robo faengt immer an
    ClearScreen();
    TextOut(0,LCD_LINE1,"Ich beginne");
    Wait(5000);

    // Robo macht ersten Zug in Zelle 4 (Mitte)
    op_symbol = 2;
    mark_cell(4);
    playfield[4] = 1;

    // simulieren des Abwechselns
    change_symbol = 2;

    turns_num--;
    move_pen(0,-3683);
    Acquire(moveMutex_x);
    Acquire(moveMutex_y);
    Release(moveMutex_x);
    Release(moveMutex_y);

    //fuer jede Runde
    for(turns=0; turns<turns_num; turns++){

        if(win == false){
            // layer = Baum tiefe
            //layer_4_nodes = 0;
            //layer_3_nodes = 0;
            //layer_2_nodes = 0;
            //child_total=0;

            // zu Beginn trat noch kein Spielstand ein, daher auf 0 gesetzt
            for(i=0;i<401;i++){
            //    nodes[i].active = 0;
            }


            move_pen(15,-3683);
            Acquire(moveMutex_x);
            Acquire(moveMutex_y);
            Release(moveMutex_x);
            Release(moveMutex_y);

            //Spielendstaende => Unentschieden oder Sieg
            if(win == false){
                ClearScreen();
                TextOut(0,LCD_LINE1,"Unentschieden");
            }
            else{
                ClearScreen();
                TextOut(0,LCD_LINE1,"Sieg");
            }

            Wait(10000);
            move_pen(0,-3683);

        }
    }
}
struct Move
{
    int row;
    int col;
};

bool isMovesLeft()
{
    for (int i = 0; i<3; i++)
        for (int j = 0; j<3; j++)
            if (playfield[i]==0)
                return true;
    return false;
}

int evaluate()
{
    oneDimPlayfieldToTwoDim();
    // Checking for Rows for X or O victory.
    for (int row = 0; row<3; row++)
    {
        if (playfieldTwoDim[row][0]==playfieldTwoDim[row][1] &&
            playfieldTwoDim[row][1]==playfieldTwoDim[row][2])
        {
            if (playfieldTwoDim[row][0]==symbol)
                return +10;
            else if (playfieldTwoDim[row][0]==op_symbol)
                return -10;
        }
    }

    // Checking for Columns for X or O victory.
    for (int col = 0; col<3; col++)
    {
        if (playfieldTwoDim[0][col]==playfieldTwoDim[1][col] &&
            playfieldTwoDim[1][col]==playfieldTwoDim[2][col])
        {
            if (playfieldTwoDim[0][col]==symbol)
                return +10;

            else if (playfieldTwoDim[0][col]==op_symbol)
                return -10;
        }
    }

    // Checking for Diagonals for X or O victory.
    if (playfieldTwoDim[0][0]==playfieldTwoDim[1][1] && playfieldTwoDim[1][1]==playfieldTwoDim[2][2])
    {
        if (playfieldTwoDim[0][0]==symbol)
            return +10;
        else if (playfieldTwoDim[0][0]==op_symbol)
            return -10;
    }

    if (playfieldTwoDim[0][2]==playfieldTwoDim[1][1] && playfieldTwoDim[1][1]==playfieldTwoDim[2][0])
    {
        if (playfieldTwoDim[0][2]==symbol)
            return +10;
        else if (playfieldTwoDim[0][2]==op_symbol)
            return -10;
    }

    // Else if none of them have won then return 0
    return 0;
}